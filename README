Lumenc - A Clojure framework for generating music.

Running: 

Open the 'lumenc' file and edit the CLOJURE variable to point to your copy of clojure.jar.  Then you can simply do

 ./lumenc your_source_file.clj

and the resultant .wav will be created in your current directory.


Notes:

This software should be considered pre-pre-alpha.  Although I'll try to keep commits such that the demos always work, the software is likely buggy and certainly the range of filters available right now leaves much to be desired.  Part of the reason I'm doing this is to learn about digital audio synthesis, so the framework provides a platform from which I can test concepts as I learn them.  

It should also be pointed out that the software is very slooooooow.  Often several times slower than real time for even the simplest of tracks.  This is for a few reasons.  The first is that Clojure itself boxes numbers between function calls, so the nature of the chained-closure setup here makes mathematical operations much slower than they might be in plain java, even when using unchecked math which is sometimes possible.  Secondly, many of the filters written herein are written with an emphasis on readability rather than speed.  My goals for this project include putting readability and 'tweakability' of the filters as the first priority, making it easy to use and extend the available filters.  Because the system is not required to run in real time, speed will always take second place to this.  I do hope to optimise whenever possible though.

How to Use:

Lumenc provides three main datastructures: waves, filters, and tracks.

Waves are digital representations of waveforms.  These are what you eventually pass to the 'render' function to create a wav file.  Filters are functions that return waves, and often take them as arguments as well.  'Deffilter' allows for the creation of filters, and calling them mostly works just like a regular function call, with a few caveats.  Tracks are representations of melodies, drum beats, or similar structures.  These can be created with 'deftrack'.

Primitive Operators:

deffilter - 
Works like defn but is designed to return a waveform.  The difference is that any arguments passed to a filter will be coerced into a wave if they aren't already one.  For example, if the number 440 is passed to a filter, the filter will instead provide a wave producing a constant output of 440.  This allows for easy use of static values in situations where waves would also be acceptable.  
A good example of this is the 'sine' function, which takes one argument, a frequency.  "(sine 440)" is an acceptable call, producing a wave that represents a 440Hz sine wave.  However, "(sine (pan 440 660 (secs 5)))" is also an acceptable call.  This call to 'pan' produces a wave whose output changes from 440 to 660 over the course of 5 seconds, and the resultant sine wave's frequency will change accordingly.
This feature can be circumvented by wrapping an arg in the arglist with parentheses.  For example, "(deffilter [foo (bar)] ...)" will produce a filter that takes two arguments.  Anything passed in as foo will be coerced to wave form, but static values passed as bar will be left alone.

wave - 
This is the primitive operator for creating waves.  It takes a body of code designed to calculate the result of the wave for any sample.  The current sample can be accessed with the variable 's'.  If you want to call other waves to determine their values, this can be done using 's', a for example "(foo s)" would get the result of the wave foo. NOTE: Although possible, it's generally not safe to call a wave with anything other than the current sample number.  Waves are expected to be called in order, so doing otherwise will probably cause the program to fail.

cwave - 
This works just like wave, but implements caching.  The first argument has to be a value representing the length to be cached.  If this value is a number N, the wave will cache the previous N samples.  If the value is nil, the wave will cache all previous samples.  The previous samples can then be accessed by calling the function 'prev' with a previous sample number, for example "(prev (dec s))" will return the immediately previous sample.  Other waves that call this wave for previous samples will also receive cached values if they're available.

mix/add - 
These operators take a series of any number of waves and combine them.  'mix' will average the waves together, while 'add' will simply add them together.

stack/rstack - 
These provide a let-like interface for easy chaining of filters together.  'stack' takes a series of label/wave pairs, and provides that label to represent that wave in future pairs.  The final wave is what's returned, and it doesn't require a label.  'rstack' works similarly but the labels are provided to any waves included, before or after.  This allows for mutual recursion, or chains of filters that feed back on each other.  NOTE: This is typically done with a delay, and the 'rdelay' filter must be used in situations where mutual recursion exists.  Conversely, 'rdelay' should never be used outside of an 'rstack', use 'buffer' instead in those instances.

Tracks:

Tracks are numerical representations of melodies, or drum beats, or anything of that nature.  They are typically defined with 'deftrack' and can be modified in various ways before being passed to a filter to be applied to a waveform.  Note lengths in tracks are measured in 'beats'.  The actual length of a beat is defined by the *bpm* global variable, and can be set with the 'with-bpm' macro when rendering.

Every track consists of a vector of notes, and an optional map containing options about the track.  The vector of notes might look something like this: "[a b (c d) e]".  'Top level' notes (that is, those not inside a list) have a length of 1 beat by default (this can be changed by setting the :bpn option in the map), while for any list L, the length of each constituent note is (beat len)/(count L).  In other words, a list is as long in total as a note on the same level.  In the example above, the notes c and d are each half a beat long, while a, b, and e are each one beat long.  Lists can contain other lists as necessary, and the same rules apply.  All tracks allow for the special symbols 'h' and 'r', which stand for hold and rest respectively.  'h' will hold the previous note for its length (and this works across list boundaries) and 'r' will produce only silence.

The track maps can contain a number of options.  Right now the options available are :oct (for defining the starting octave), :bpn (defining how long a top-level note will last), and :type (currently only :raw or :note.  Raw tracks simply use the given values as-is, while note tracks take the values in the track and transform them into frequencies).

Note tracks:

There are different types of tracks, and note tracks will take note symbols and return frequencies automatically.  A note symbol represents a specific note, some examples are 'a', 'b#', 'c4b', etc.  Each contains a note (a to g) and optionally a b/#/n for flat, sharp, or natural, and a number representing the octave of the note.  Octaves begin with C as the lowest note, and the octave which starts with middle C is 4.  4 is also the default octave for tracks to begin with.  If a note doesn't contain an octave number, the octave of the immediately previous note will be used.  This makes it only occasionally necessary to use the octave numbers.   

Deftrack:

Deftrack is the main function used to define tracks.  Deftrack takes a series of forms, alternating between 'names' and 'track pieces'.  This is easiest to explain by example.  Consider the demo track:

(deftrack
  dm1 dm2 dm3 {:type :note :bpn 2 :oct 3}
   
  dm1 [ (a c4)  e       (d g) e        ]
  dm2 [  r     (r c h h) h   (h c h h) ]
  dm3 [  r     (r   e  ) h   (h   e  ) ]
	  
  dm1 [ (d a)  e        b   c5 ]
  dm2 [  h    (h e h h) b2  a  ]
  dm3 [  h    (h   c  ) r   r  ])

The 'names' in this example are 'dm1', 'dm2', and 'dm3'.  The track pieces are the vectors and maps used.  When multiple names are used before a track piece (such as in the first line), that piece will be associated with all three names.  When multiple pieces are used after a name or names, those pieces will be concatenated together.  Each of the track pieces associated with a name is concatenated together in order (or merged in the case of a map) and the result is then considered the whole track.  This allows you to define multiple tracks in parallel without having to worry about line wrapping.  
